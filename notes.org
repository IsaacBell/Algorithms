#+TITLE: Notes

TODO Data Structures
** [x] Sparse Tables
** [x] Segment Trees
** [x] Monotonic Stacks/Queues
** [ ] Heavy/Light Decompositions

TODO Algorithms
** [ ] Kosaraju's
** [x] Djikstra's
** [x] Tarjan's
** [ ] Kruskal's
** [x] Rabin-Karp

TODO Study

** [ ] Segment Tree Beats
** [ ] Network Flows
*** [ ] Dinic's
*** [ ] Floyd-Warshall
*** [ ] Edmonds-Karp
** Combinatorics
*** [x] Basics/Intro Problems
*** [ ] Intermediate
*** [ ] Advanced
** Number Theory
*** [x] Sieve of Eratosthenes
*** [ ] Prime Number Theory
*** [ ] Factorialization Concepts
** Range Queries
*** [ ] Lazy Segment Trees
*** [ ] "Beats"
** Geometry
*** [x] Bounding Boxes
*** [x] Cross Product
*** [x] Computing Area of a Triangle
*** [ ] Maximal Rectangle
*** [ ] Histograms

PROJ Segment Trees
** Padding tree with 0's to make a power of two

#+begin_src C++ :includes <stdio.h>
  int n; cin >> n;
  vector<int> tree;
  // Padding tree - don't need to pad A
  while(__builtin_popcount(n) != 1)
    n++;
  tree.resize(2 * n);
#+end_src

* Range Query Updates
** How to increase each value in a range by u?
** Add the update val to the two nodes which comprise the entire range
*** Ask our children to provide us a sum of their data, I add my own, and we keep heading down towards root.
** #+begin_src C++ :includes <stdio.h>
ll query(ll node, ll lo, ll hi, ll a, ll b, ll val) {
    // If node range within query range,
    // first update the value if this is an update query,
    // then return the value at the given node
    if (a <= lo && b >= hi) {
        if (val != 1) tree[node] = val;
        return tree[node];
    }

    // Check if node range and query range are disjoint
    if (hi < a || b < lo)
        return 0;

    // Logarithmetically, recursively sum child nodes
    ll mid = (lo + hi) / 2;

    auto sum = query(2*node,  lo, mid, a, b, val)
             + query(2*node+1, mid+1, hi, a, b, val);

    // Handle updates
    tree[node] = tree[node * 2] + tree[node * 2 + 1];
    return sum;
}

int main() {
    ...
    for (i, q) {
        int type; cin >> type;
        if (type == 1) { // update
            int lo, hi, u;
            cin >> lo >> hi >> u;
            lo --;
            hi--;
            query(1, 0, n - 1, lo, hi, u);
        } else {
            int k; cin >> k;
            k--;
            cout << change(1, 0, n-1, k, k, -1) << "\n";
        }
    }
}
#+end_src
